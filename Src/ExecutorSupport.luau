--[[
	éå¸¸è½»é‡çš„æ£€æµ‹å™¨ï¼Œç”¨äºæ£€æŸ¥å„ç§æ‰§è¡Œå™¨å‡½æ•°æ˜¯å¦å­˜åœ¨å¹¶èƒ½æ­£å¸¸å·¥ä½œã€‚
	éƒ¨åˆ†æ£€æµ‹è¿˜ä¼šéªŒè¯å‡½æ•°æ˜¯å¦æŒ‰é¢„æœŸå·¥ä½œï¼Œè€Œä¸ä»…ä»…æ˜¯å­˜åœ¨ã€‚
]]

local ExecutorSupport = {
	FailedChecks = {}, -- ä¿å­˜å¤±è´¥çš„æ£€æµ‹é¡¹
}

-- æ£€æŸ¥ FFlag å€¼
local function CheckFFlagValue(Name: string, Value: any)
	local Success, Result = pcall(getfflag, Name)
	if not Success then
		return false
	end

	if typeof(Result) == "boolean" then
		return Result
	end

	if typeof(Result) == "string" then
		return Result == tostring(Value)
	end

	return false
end

-- æµ‹è¯•å‡½æ•°å°è£…
local function test(name, Callback, CheckType)
	local TestFunction = not CheckType and Callback or function()
		return typeof(Callback) == "function"
	end

	local Success, Result = pcall(TestFunction)
	ExecutorSupport[name] = {
		IsWorking = Success, -- æ˜¯å¦å¯ç”¨
		Details = Result,    -- ç»“æœä¿¡æ¯
	}

	if not Success then
		table.insert(ExecutorSupport.FailedChecks, name)
	end
end

-- ğŸ”¹ FFlag åº“æ£€æµ‹
test("getfflag", getfflag, true)
test("setfflag", setfflag, true)

-- ğŸ”¹ Actor åº“æ£€æµ‹
test("getactors", getactors, true)
test("run_on_actor", run_on_actor, true)
test("getnilinstances", getnilinstances, true)

-- ğŸ”¹ é—­åŒ…åº“æ£€æµ‹
test("newcclosure", function()
	assert(typeof(newcclosure) == "function", "newcclosure ä¸æ˜¯å‡½æ•°")
	local CClosure = newcclosure(function() return true end)

	assert(typeof(CClosure) == "function", "newcclosure æ²¡æœ‰è¿”å›å‡½æ•°")
	assert(CClosure() == true, "æœªèƒ½åˆ›å»ºæ–°çš„é—­åŒ…")
	
	assert(debug.info(CClosure, "s") == "[C]", "newcclosure æœªèƒ½åˆ›å»º C é—­åŒ…")
end, true)

test("checkcaller", checkcaller, true)
test("getcallingscript", getcallingscript, true)

-- hookfunction æµ‹è¯•
test("hookfunction", function()
	assert(typeof(hookfunction) == "function", "hookfunction ä¸æ˜¯å‡½æ•°")
	
	local function Original(a, b)
		return a + b
	end

	local ref = hookfunction(Original, function(a, b)
		return a * b
	end)

	assert(Original(2, 3) == 6, "æœªèƒ½ hook å‡½æ•°å¹¶æ”¹å˜è¿”å›å€¼")
	assert(ref(2, 3) == 5, "æœªè¿”å›åŸå§‹å‡½æ•°")
end)

-- isfunctionhooked æµ‹è¯•
test("isfunctionhooked", function()
	assert(typeof(isfunctionhooked) == "function", "isfunctionhooked ä¸æ˜¯å‡½æ•°")
	assert(typeof(hookfunction) == "function", "æ­¤æµ‹è¯•éœ€è¦ hookfunction")
	
	local function Original(a, b)
		return a + b
	end

	assert(isfunctionhooked(Original) == false, "æœª hook çš„å‡½æ•°è¿”å›äº† true")

	hookfunction(Original, function(a, b)
		return a * b
	end)

	assert(isfunctionhooked(Original) == true, "å·² hook çš„å‡½æ•°è¿”å›äº† false")
end)

-- restorefunction æµ‹è¯•
test("restorefunction", function()
	assert(typeof(restorefunction) == "function", "restorefunction ä¸æ˜¯å‡½æ•°")
	assert(typeof(hookfunction) == "function", "æ­¤æµ‹è¯•éœ€è¦ hookfunction")
	
	local function Original(a, b)
		return a + b
	end

	hookfunction(Original, function(a, b)
		return a * b
	end)

	assert(Original(2, 3) == 6, "æœªèƒ½ hook å‡½æ•°")

	restorefunction(Original)

	assert(Original(2, 3) == 5, "restorefunction æœªèƒ½æ¢å¤åŸå§‹å‡½æ•°")
end)

-- ğŸ”¹ å…ƒæ–¹æ³• hook æµ‹è¯•
test("hookmetamethod", function()
	assert(typeof(hookmetamethod) == "function", "hookmetamethod ä¸æ˜¯å‡½æ•°")
	
	local object = setmetatable({}, {
		__index = newcclosure(function() return false end),
		__metatable = "Locked!"
	})

	local ref = hookmetamethod(object, "__index", function()
		return true
	end)

	assert(object.test == true, "æœªèƒ½ hook metamethod å¹¶æ”¹å˜è¿”å›å€¼")
	assert(ref() == false, "æœªè¿”å›åŸå§‹å‡½æ•°")
end)

-- getnamecallmethod æµ‹è¯•
test("getnamecallmethod", function()
	assert(typeof(getnamecallmethod) == "function", "getnamecallmethod ä¸æ˜¯å‡½æ•°")

	pcall(function()
		game:TEST_NAMECALL_METHOD()
	end)

	assert(
		getnamecallmethod() == "TEST_NAMECALL_METHOD",
		"getnamecallmethod æœªè¿”å›çœŸå®çš„æ–¹æ³•å"
	)
end)

-- getrawmetatable æµ‹è¯•
test("getrawmetatable", function()
	assert(typeof(getrawmetatable) == "function", "getrawmetatable ä¸æ˜¯å‡½æ•°")

	local BaseLockedMetatable = {
		__index = function() return false end,
		__metatable = "Locked!"
	}

	local TestMetatable = setmetatable({}, BaseLockedMetatable)

	local FetchedMetatable = getrawmetatable(TestMetatable)
	assert(typeof(FetchedMetatable) == "table", "getrawmetatable æœªè¿”å›è¡¨")
	
	assert(FetchedMetatable.__index() == false, "æœªè¿”å›æ­£ç¡®çš„ __index()")
	assert(FetchedMetatable.__metatable == "Locked!", "æœªè¿”å›æ­£ç¡®çš„é”å®š mt")

	assert(FetchedMetatable == BaseLockedMetatable, "æœªè¿”å›ç›¸åŒçš„å…ƒè¡¨")
end)

-- ğŸ”¹ å®ä¾‹ç›¸å…³å‡½æ•°æ£€æµ‹
test("getcallbackvalue", function()
	assert(typeof(getcallbackvalue) == "function", "getcallbackvalue ä¸æ˜¯å‡½æ•°")

	local bindable = Instance.new("BindableFunction")
	local InvokeFunction = function(value) return value * 2 end
	bindable.OnInvoke = InvokeFunction

	local FetchedInvoke = getcallbackvalue(bindable, "OnInvoke")
	bindable:Destroy()

	assert(typeof(FetchedInvoke) == "function", "æœªè¿”å›å‡½æ•°")
	assert(FetchedInvoke(5) == 10, "æœªè¿”å›æ­£ç¡®ç»“æœ")
	assert(FetchedInvoke == InvokeFunction, "æœªè¿”å›åŸå§‹å‡½æ•°")
end)

test("getnilinstances", function()
	assert(typeof(getnilinstances) == "function", "getnilinstances ä¸æ˜¯å‡½æ•°")

	local NilInstances = getnilinstances()
	assert(typeof(NilInstances) == "table", "æœªè¿”å›è¡¨")
end)

test("getconnections", function()
	assert(typeof(getconnections) == "function", "getconnections ä¸æ˜¯å‡½æ•°")

	local Event = Instance.new("BindableEvent")
	local ConnectionFunction = function() end
	local OnceFunction = function() end
	
	Event.Event:Connect(ConnectionFunction)
	Event.Event:Once(OnceFunction)
	task.spawn(function() Event.Event:Wait() end)

	local Connections = getconnections(Event.Event)

	assert(typeof(Connections) == "table", "æœªè¿”å›è¡¨")
	assert(#Connections == 3, "è¿”å›çš„è¿æ¥æ•°é‡é”™è¯¯")

	local FoundFunctions = {}
	for _, Connection in Connections do
		local _, ConnFunc = pcall(function()
			return Connection.Function
		end)

		if typeof(ConnFunc) == "function" then
			table.insert(FoundFunctions, ConnFunc)
		end
	end

	assert(table.find(FoundFunctions, ConnectionFunction) ~= nil, "æœªæ‰¾åˆ°æ­£ç¡®çš„ [:Connect()] è¿æ¥")
	assert(table.find(FoundFunctions, OnceFunction) ~= nil, "æœªæ‰¾åˆ°æ­£ç¡®çš„ [:Once()] è¿æ¥")

	Event:Destroy()
end)

test("firesignal", function()
	assert(typeof(firesignal) == "function", "firesignal ä¸æ˜¯å‡½æ•°")
	
	local event = Instance.new("BindableEvent")
	local fired = false

	event.Event:Once(function(value)
		fired = value
	end)

	firesignal(event.Event, true)
	task.wait(0.1)
	event:Destroy()

	assert(fired, "æœªèƒ½è§¦å‘ BindableEvent")
end)

test("cloneref", function()
	assert(typeof(cloneref) == "function", "cloneref ä¸æ˜¯å‡½æ•°")

	local ref = cloneref(game)
	assert(ref ~= game, "æœªæ­£ç¡®å…‹éš†å®ä¾‹å¼•ç”¨")
	assert(typeof(ref) == "Instance", "æœªè¿”å›å®ä¾‹")
end)

test("compareinstances", function()
	assert(typeof(compareinstances) == "function", "compareinstances ä¸æ˜¯å‡½æ•°")
	assert(typeof(cloneref) == "function", "æ­¤æµ‹è¯•éœ€è¦ cloneref")

	assert(compareinstances(game, cloneref(game)) == true, "ç›¸åŒå®ä¾‹æœªè¿”å› true")
	assert(compareinstances(game, workspace) == false, "ä¸åŒå®ä¾‹æœªè¿”å› false")
end)

-- ğŸ”¹ é’ˆå¯¹ Actor å’Œ FFlag çš„è¡¥å……æ£€æµ‹
if CheckFFlagValue("DebugRunParallelLuaOnMainThread", false) and not ExecutorSupport["run_on_actor"].IsWorking then
	task.spawn(function()
		if not game:IsLoaded() then
			game.Loaded:Wait()
		end
		
		local GameUsesActors = false
		
		local CategoryToSearch = { game:GetDescendants() }
		if ExecutorSupport["getnilinstances"].IsWorking then
			table.insert(CategoryToSearch, getnilinstances())
		end

		for _, Category in CategoryToSearch do
			if GameUsesActors then
				break
			end
		
			for _, Instance in Category do
				if not Instance:IsA("Actor") then
					continue
				end
		
				GameUsesActors = true
				break
			end
		end
		
		if not GameUsesActors then
			return
		end
		
		local bindable = Instance.new("BindableFunction")
	
		function bindable.OnInvoke(response)
			if response == "Set FFlag" then
				setfflag("DebugRunParallelLuaOnMainThread", "true")
				wax.shared.StarterGui:SetCore("SendNotification", {
					Title = "Cobalt",
					Text = "è¯·é‡æ–°åŠ å…¥ä»¥ä½¿ FFlag ç”Ÿæ•ˆï¼",
					Duration = math.huge,
				})
			end
	
			bindable:Destroy()
		end
	
		wax.shared.StarterGui:SetCore("SendNotification", {
			Title = "Cobalt",
			Text = "æ£€æµ‹åˆ°å¯èƒ½ä½¿ç”¨äº† Actorsï¼Œä½†ä½ çš„æ‰§è¡Œå™¨ä¸æ”¯æŒã€‚æˆ‘ä»¬å¯ä»¥ä¸ºä½ è®¾ç½®ä¸€ä¸ª FFlagï¼Œä¸‹æ¬¡åŠ å…¥æ—¶å³å¯æ£€æµ‹åˆ° Actor remotesã€‚",
			Duration = math.huge,
			Callback = bindable,
			Button1 = "è®¾ç½® FFlag",
			Button2 = "å–æ¶ˆ",
		})
	end)
end

return ExecutorSupport
